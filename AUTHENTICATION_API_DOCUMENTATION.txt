================================================================================
                    AUTHENTICATION API DOCUMENTATION
                    Spring Boot JWT Authentication System
================================================================================

VERSION: 1.0.0
BASE URL: http://localhost:8080
API PREFIX: /api/v1/auth
LAST UPDATED: 2025-12-30

================================================================================
TABLE OF CONTENTS
================================================================================
1. Overview
2. Authentication Flow
3. API Endpoints
   3.1 User Registration (Signup)
   3.2 User Login
   3.3 OAuth2 Token Exchange
   3.4 Refresh Access Token
   3.5 User Logout
   3.6 Email Verification
   3.7 Forgot Password
   3.8 Reset Password
4. Request & Response Formats
5. Error Handling
6. Security Considerations
7. Integration Examples for Next.js

================================================================================
1. OVERVIEW
================================================================================

This authentication API provides a complete JWT-based authentication system with:
- Email/Password authentication
- OAuth2 integration (Google, GitHub, Facebook)
- JWT access tokens (15 minutes expiry)
- Refresh tokens (7 days expiry)
- Email verification
- Password reset functionality
- Rate limiting and security features

CORS Configuration:
- Allowed Origins: http://localhost:3000, http://localhost:8080
- Allowed Methods: GET, POST, PUT, DELETE, PATCH, OPTIONS
- Credentials: Enabled

================================================================================
2. AUTHENTICATION FLOW
================================================================================

Standard Login Flow:
1. User signs up → POST /api/v1/auth/signup
2. User verifies email → GET /api/v1/auth/verify-email?token={token}
3. User logs in → POST /api/v1/auth/login
4. Server returns access token + refresh token
5. Client stores tokens (localStorage/cookies)
6. Client includes access token in Authorization header for protected requests
7. When access token expires, use refresh token → POST /api/v1/auth/refresh
8. On logout → POST /api/v1/auth/logout

OAuth2 Flow:
1. User clicks "Login with Google/GitHub"
2. Redirect to OAuth2 provider
3. Provider redirects back with token
4. Exchange token → POST /api/v1/auth/oauth2/token
5. Server returns JWT tokens (same as standard login)

================================================================================
3. API ENDPOINTS
================================================================================

--------------------------------------------------------------------------------
3.1 USER REGISTRATION (SIGNUP)
--------------------------------------------------------------------------------

Endpoint: POST /api/v1/auth/signup
Description: Create a new user account with email and password
Authentication: Not required

REQUEST BODY:
{
  "email": "user@example.com",
  "password": "SecurePass123",
  "firstName": "John",
  "lastName": "Doe"
}

FIELD VALIDATIONS:
- email: Required, must be valid email format
- password: Required, minimum 8 characters
- firstName: Required, 2-50 characters
- lastName: Optional, maximum 50 characters

SUCCESS RESPONSE (201 Created):
{
  "success": true,
  "message": "User registered successfully. Please verify your email.",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 900000,
    "user": {
      "id": 1,
      "email": "user@example.com",
      "firstName": "John",
      "lastName": "Doe",
      "emailVerified": false,
      "status": "ACTIVE"
    }
  },
  "timestamp": "2025-12-30T13:08:31"
}

ERROR RESPONSES:
- 400 Bad Request: Invalid input data or email already exists
- 500 Internal Server Error: Server error

--------------------------------------------------------------------------------
3.2 USER LOGIN
--------------------------------------------------------------------------------

Endpoint: POST /api/v1/auth/login
Description: Authenticate user with email and password
Authentication: Not required

REQUEST BODY:
{
  "email": "user@example.com",
  "password": "SecurePass123"
}

FIELD VALIDATIONS:
- email: Required
- password: Required

SUCCESS RESPONSE (200 OK):
{
  "success": true,
  "message": "Login successful",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 900000,
    "user": {
      "id": 1,
      "email": "user@example.com",
      "firstName": "John",
      "lastName": "Doe",
      "emailVerified": true,
      "status": "ACTIVE"
    }
  },
  "timestamp": "2025-12-30T13:08:31"
}

ERROR RESPONSES:
- 401 Unauthorized: Invalid credentials
- 423 Locked: Account locked due to too many failed attempts (5 attempts, 15 min lockout)
- 500 Internal Server Error: Server error

--------------------------------------------------------------------------------
3.3 OAUTH2 TOKEN EXCHANGE
--------------------------------------------------------------------------------

Endpoint: POST /api/v1/auth/oauth2/token
Description: Exchange OAuth2 token from redirect URL for JWT access and refresh tokens
Authentication: Not required

REQUEST BODY:
{
  "token": "oauth2_token_from_redirect",
  "provider": "google"
}

FIELD VALIDATIONS:
- token: Required
- provider: Optional (google, github, facebook)

SUCCESS RESPONSE (200 OK):
{
  "success": true,
  "message": "OAuth2 login successful",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 900000,
    "user": {
      "id": 1,
      "email": "user@example.com",
      "firstName": "John",
      "lastName": "Doe",
      "emailVerified": true,
      "status": "ACTIVE"
    }
  },
  "timestamp": "2025-12-30T13:08:31"
}

ERROR RESPONSES:
- 401 Unauthorized: Invalid OAuth2 token
- 500 Internal Server Error: Server error

--------------------------------------------------------------------------------
3.4 REFRESH ACCESS TOKEN
--------------------------------------------------------------------------------

Endpoint: POST /api/v1/auth/refresh
Description: Get new access token using refresh token
Authentication: Not required (uses refresh token in body)

REQUEST BODY:
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

FIELD VALIDATIONS:
- refreshToken: Required

SUCCESS RESPONSE (200 OK):
{
  "success": true,
  "message": "Token refreshed successfully",
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 900000,
    "user": {
      "id": 1,
      "email": "user@example.com",
      "firstName": "John",
      "lastName": "Doe",
      "emailVerified": true,
      "status": "ACTIVE"
    }
  },
  "timestamp": "2025-12-30T13:08:31"
}

ERROR RESPONSES:
- 401 Unauthorized: Invalid or expired refresh token
- 500 Internal Server Error: Server error

--------------------------------------------------------------------------------
3.5 USER LOGOUT
--------------------------------------------------------------------------------

Endpoint: POST /api/v1/auth/logout
Description: Logout user and revoke refresh token
Authentication: Not required (uses refresh token in body)

REQUEST BODY:
{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

FIELD VALIDATIONS:
- refreshToken: Required

SUCCESS RESPONSE (200 OK):
{
  "success": true,
  "message": "Logout successful",
  "timestamp": "2025-12-30T13:08:31"
}

ERROR RESPONSES:
- 400 Bad Request: Invalid refresh token
- 500 Internal Server Error: Server error

--------------------------------------------------------------------------------
3.6 EMAIL VERIFICATION
--------------------------------------------------------------------------------

Endpoint: GET /api/v1/auth/verify-email
Description: Verify user email address with token
Authentication: Not required

QUERY PARAMETERS:
- token: Required (verification token sent to email)

EXAMPLE:
GET /api/v1/auth/verify-email?token=abc123def456

SUCCESS RESPONSE (200 OK):
{
  "success": true,
  "message": "Email verified successfully",
  "timestamp": "2025-12-30T13:08:31"
}

ERROR RESPONSES:
- 400 Bad Request: Invalid or expired token (24 hours expiry)
- 500 Internal Server Error: Server error

--------------------------------------------------------------------------------
3.7 FORGOT PASSWORD
--------------------------------------------------------------------------------

Endpoint: POST /api/v1/auth/forgot-password
Description: Request password reset email
Authentication: Not required

QUERY PARAMETERS:
- email: Required (valid email format)

EXAMPLE:
POST /api/v1/auth/forgot-password?email=user@example.com

SUCCESS RESPONSE (200 OK):
{
  "success": true,
  "message": "Password reset email sent",
  "timestamp": "2025-12-30T13:08:31"
}

NOTE: For security, this endpoint always returns success even if email doesn't exist

ERROR RESPONSES:
- 400 Bad Request: Invalid email format
- 500 Internal Server Error: Server error

--------------------------------------------------------------------------------
3.8 RESET PASSWORD
--------------------------------------------------------------------------------

Endpoint: POST /api/v1/auth/reset-password
Description: Reset password with token
Authentication: Not required

QUERY PARAMETERS:
- token: Required (reset token from email)
- newPassword: Required (minimum 6 characters)

EXAMPLE:
POST /api/v1/auth/reset-password?token=abc123def456&newPassword=NewSecurePass123

SUCCESS RESPONSE (200 OK):
{
  "success": true,
  "message": "Password reset successfully",
  "timestamp": "2025-12-30T13:08:31"
}

ERROR RESPONSES:
- 400 Bad Request: Invalid or expired token (1 hour expiry)
- 500 Internal Server Error: Server error

================================================================================
4. REQUEST & RESPONSE FORMATS
================================================================================

CONTENT TYPE:
All requests and responses use: application/json

AUTHORIZATION HEADER (for protected endpoints):
Authorization: Bearer {accessToken}

STANDARD RESPONSE STRUCTURE:
{
  "success": boolean,        // true for success, false for error
  "message": string,         // Human-readable message
  "data": object | null,     // Response data (null for errors)
  "timestamp": string        // ISO 8601 timestamp
}

TOKEN INFORMATION:
- Access Token Expiry: 15 minutes (900000 milliseconds)
- Refresh Token Expiry: 7 days (604800000 milliseconds)
- Token Type: Bearer
- Token Format: JWT (JSON Web Token)

USER OBJECT STRUCTURE:
{
  "id": number,
  "email": string,
  "firstName": string,
  "lastName": string,
  "emailVerified": boolean,
  "status": string           // ACTIVE, INACTIVE, LOCKED
}

================================================================================
5. ERROR HANDLING
================================================================================

COMMON HTTP STATUS CODES:
- 200 OK: Request successful
- 201 Created: Resource created successfully
- 400 Bad Request: Invalid input or validation error
- 401 Unauthorized: Authentication failed or token invalid
- 403 Forbidden: Access denied
- 423 Locked: Account locked due to failed login attempts
- 429 Too Many Requests: Rate limit exceeded
- 500 Internal Server Error: Server error

ERROR RESPONSE FORMAT:
{
  "success": false,
  "message": "Error description",
  "timestamp": "2025-12-30T13:08:31"
}

VALIDATION ERROR EXAMPLE:
{
  "success": false,
  "message": "Validation failed",
  "data": {
    "email": "Email must be valid",
    "password": "Password must be at least 8 characters"
  },
  "timestamp": "2025-12-30T13:08:31"
}

RATE LIMITING:
- Enabled: true
- Capacity: 100 requests
- Refill: 10 tokens per second
- Response: 429 Too Many Requests when exceeded

LOGIN ATTEMPT LIMITS:
- Max Attempts: 5 failed attempts
- Lockout Duration: 15 minutes
- Response: 423 Locked when account is locked

================================================================================
6. SECURITY CONSIDERATIONS
================================================================================

TOKEN STORAGE (Next.js):
1. RECOMMENDED: Store tokens in httpOnly cookies (most secure)
2. ALTERNATIVE: Store in localStorage (vulnerable to XSS)
3. NEVER: Store in regular cookies without httpOnly flag

TOKEN USAGE:
- Always send access token in Authorization header
- Never expose tokens in URLs or logs
- Implement token refresh before expiry
- Clear tokens on logout

HTTPS:
- Use HTTPS in production
- Never send credentials over HTTP

CSRF PROTECTION:
- Implement CSRF tokens for state-changing operations
- Use SameSite cookie attribute

PASSWORD REQUIREMENTS:
- Minimum 8 characters
- Recommend: uppercase, lowercase, numbers, special characters

================================================================================
7. INTEGRATION EXAMPLES FOR NEXT.JS
================================================================================

--------------------------------------------------------------------------------
7.1 API CLIENT SETUP (lib/api.ts)
--------------------------------------------------------------------------------

import axios from 'axios';

const API_BASE_URL = 'http://localhost:8080/api/v1';

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  withCredentials: true, // Enable CORS credentials
});

// Request interceptor to add access token
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor to handle token refresh
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // If 401 and not already retried, try to refresh token
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = localStorage.getItem('refreshToken');
        const response = await axios.post(
          `${API_BASE_URL}/auth/refresh`,
          { refreshToken }
        );

        const { accessToken, refreshToken: newRefreshToken } = response.data.data;
        
        localStorage.setItem('accessToken', accessToken);
        localStorage.setItem('refreshToken', newRefreshToken);

        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return apiClient(originalRequest);
      } catch (refreshError) {
        // Refresh failed, logout user
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

export default apiClient;

--------------------------------------------------------------------------------
7.2 AUTH SERVICE (services/authService.ts)
--------------------------------------------------------------------------------

import apiClient from '@/lib/api';

export interface SignupData {
  email: string;
  password: string;
  firstName: string;
  lastName?: string;
}

export interface LoginData {
  email: string;
  password: string;
}

export interface AuthResponse {
  accessToken: string;
  refreshToken: string;
  tokenType: string;
  expiresIn: number;
  user: {
    id: number;
    email: string;
    firstName: string;
    lastName: string;
    emailVerified: boolean;
    status: string;
  };
}

class AuthService {
  async signup(data: SignupData): Promise<AuthResponse> {
    const response = await apiClient.post('/auth/signup', data);
    const authData = response.data.data;
    this.setTokens(authData.accessToken, authData.refreshToken);
    return authData;
  }

  async login(data: LoginData): Promise<AuthResponse> {
    const response = await apiClient.post('/auth/login', data);
    const authData = response.data.data;
    this.setTokens(authData.accessToken, authData.refreshToken);
    return authData;
  }

  async loginWithOAuth2(token: string, provider?: string): Promise<AuthResponse> {
    const response = await apiClient.post('/auth/oauth2/token', { token, provider });
    const authData = response.data.data;
    this.setTokens(authData.accessToken, authData.refreshToken);
    return authData;
  }

  async refreshToken(): Promise<AuthResponse> {
    const refreshToken = localStorage.getItem('refreshToken');
    if (!refreshToken) throw new Error('No refresh token');

    const response = await apiClient.post('/auth/refresh', { refreshToken });
    const authData = response.data.data;
    this.setTokens(authData.accessToken, authData.refreshToken);
    return authData;
  }

  async logout(): Promise<void> {
    const refreshToken = localStorage.getItem('refreshToken');
    if (refreshToken) {
      await apiClient.post('/auth/logout', { refreshToken });
    }
    this.clearTokens();
  }

  async verifyEmail(token: string): Promise<void> {
    await apiClient.get(`/auth/verify-email?token=${token}`);
  }

  async forgotPassword(email: string): Promise<void> {
    await apiClient.post(`/auth/forgot-password?email=${email}`);
  }

  async resetPassword(token: string, newPassword: string): Promise<void> {
    await apiClient.post(`/auth/reset-password?token=${token}&newPassword=${newPassword}`);
  }

  private setTokens(accessToken: string, refreshToken: string): void {
    localStorage.setItem('accessToken', accessToken);
    localStorage.setItem('refreshToken', refreshToken);
  }

  private clearTokens(): void {
    localStorage.removeItem('accessToken');
    localStorage.removeItem('refreshToken');
  }

  getAccessToken(): string | null {
    return localStorage.getItem('accessToken');
  }

  isAuthenticated(): boolean {
    return !!this.getAccessToken();
  }
}

export default new AuthService();

--------------------------------------------------------------------------------
7.3 USAGE IN COMPONENTS
--------------------------------------------------------------------------------

// Login Component Example
'use client';

import { useState } from 'react';
import authService from '@/services/authService';
import { useRouter } from 'next/navigation';

export default function LoginPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({ email: '', password: '' });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const response = await authService.login(formData);
      console.log('Login successful:', response.user);
      router.push('/dashboard');
    } catch (err: any) {
      setError(err.response?.data?.message || 'Login failed');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={formData.email}
        onChange={(e) => setFormData({ ...formData, email: e.target.value })}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={formData.password}
        onChange={(e) => setFormData({ ...formData, password: e.target.value })}
        placeholder="Password"
        required
      />
      {error && <p className="error">{error}</p>}
      <button type="submit" disabled={loading}>
        {loading ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
}

// Signup Component Example
'use client';

import { useState } from 'react';
import authService from '@/services/authService';
import { useRouter } from 'next/navigation';

export default function SignupPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    firstName: '',
    lastName: '',
  });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const response = await authService.signup(formData);
      console.log('Signup successful:', response.user);
      router.push('/verify-email-notice');
    } catch (err: any) {
      setError(err.response?.data?.message || 'Signup failed');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={formData.email}
        onChange={(e) => setFormData({ ...formData, email: e.target.value })}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={formData.password}
        onChange={(e) => setFormData({ ...formData, password: e.target.value })}
        placeholder="Password (min 8 characters)"
        required
      />
      <input
        type="text"
        value={formData.firstName}
        onChange={(e) => setFormData({ ...formData, firstName: e.target.value })}
        placeholder="First Name"
        required
      />
      <input
        type="text"
        value={formData.lastName}
        onChange={(e) => setFormData({ ...formData, lastName: e.target.value })}
        placeholder="Last Name (optional)"
      />
      {error && <p className="error">{error}</p>}
      <button type="submit" disabled={loading}>
        {loading ? 'Creating account...' : 'Sign Up'}
      </button>
    </form>
  );
}

--------------------------------------------------------------------------------
7.4 PROTECTED ROUTE MIDDLEWARE (middleware.ts)
--------------------------------------------------------------------------------

import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const token = request.cookies.get('accessToken')?.value;

  // If accessing protected route without token, redirect to login
  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // If accessing auth pages with token, redirect to dashboard
  if (token && (request.nextUrl.pathname === '/login' || request.nextUrl.pathname === '/signup')) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ['/dashboard/:path*', '/login', '/signup'],
};

--------------------------------------------------------------------------------
7.5 CONTEXT PROVIDER (Optional - for global auth state)
--------------------------------------------------------------------------------

'use client';

import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import authService, { AuthResponse } from '@/services/authService';

interface AuthContextType {
  user: AuthResponse['user'] | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  signup: (data: any) => Promise<void>;
  logout: () => Promise<void>;
  isAuthenticated: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<AuthResponse['user'] | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Check if user is logged in on mount
    const token = authService.getAccessToken();
    if (token) {
      // Optionally fetch user data from a /me endpoint
      setLoading(false);
    } else {
      setLoading(false);
    }
  }, []);

  const login = async (email: string, password: string) => {
    const response = await authService.login({ email, password });
    setUser(response.user);
  };

  const signup = async (data: any) => {
    const response = await authService.signup(data);
    setUser(response.user);
  };

  const logout = async () => {
    await authService.logout();
    setUser(null);
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        loading,
        login,
        signup,
        logout,
        isAuthenticated: !!user,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}

================================================================================
END OF DOCUMENTATION
================================================================================

For additional information or support:
- Swagger UI: http://localhost:8080/swagger-ui.html
- API Docs: http://localhost:8080/api-docs
- Health Check: http://localhost:8080/actuator/health

IMPORTANT NOTES:
1. Change JWT_SECRET in production to a secure random key
2. Use HTTPS in production
3. Implement proper error handling and logging
4. Consider using httpOnly cookies instead of localStorage for tokens
5. Implement CSRF protection for production
6. Rate limiting is enabled - handle 429 responses appropriately
7. Email verification tokens expire in 24 hours
8. Password reset tokens expire in 1 hour
9. Access tokens expire in 15 minutes
10. Refresh tokens expire in 7 days
